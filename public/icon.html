<!DOCTYPE html>
<html lang="zh-CN" style="margin: 0; padding: 0; overflow: hidden;">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ArtHub Icon</title>
  <style>
    * {
      margin: 0 !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }

    html, body {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
      padding: 0 !important;
      overflow: hidden !important;
      background: transparent !important;
      /* macOS 需要明确设置背景为透明 */
      -webkit-app-region: drag !important;
    }

    body {
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      cursor: move !important;
      user-select: none !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      background: transparent !important;
      /* 移除 macOS 默认的白色背景 */
      background-color: transparent !important;
    }

    #icon-container {
      width: 100% !important;
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      overflow: visible !important;
      background: transparent !important;
      background-color: transparent !important;
      /* macOS 圆角支持 */
      border-radius: 0 !important;
    }

    #icon {
      width: 90% !important;
      height: 90% !important;
      max-width: 90% !important;
      max-height: 90% !important;
      object-fit: contain !important;
      object-position: center !important;
      pointer-events: none !important;
      display: block !important;
      background: transparent !important;
    }
  </style>
</head>
<body>
  <div id="icon-container">
    <img id="icon" src="/icon.ico" alt="ArtHub" />
  </div>
  <script>
    // 动态检测窗口实际大小并调整图标
    function adjustIconSize() {
      const icon = document.getElementById('icon');
      const container = document.getElementById('icon-container');
      const body = document.body;
      const html = document.documentElement;
      
      // 获取实际窗口大小
      const windowWidth = window.innerWidth || html.clientWidth || body.clientWidth;
      const windowHeight = window.innerHeight || html.clientHeight || body.clientHeight;
      
      // 计算图标大小：窗口大小的 90%，留出 10% 边距
      const iconSize = Math.min(windowWidth, windowHeight) * 0.9;
      
      // 设置图标大小
      icon.style.width = iconSize + 'px';
      icon.style.height = iconSize + 'px';
      icon.style.maxWidth = iconSize + 'px';
      icon.style.maxHeight = iconSize + 'px';
      
      console.log('=== Icon Window Debug ===');
      console.log('Window size:', windowWidth, 'x', windowHeight);
      console.log('Icon size:', iconSize, 'x', iconSize);
      console.log('Icon natural size:', icon.naturalWidth, 'x', icon.naturalHeight);
      console.log('Icon actual size:', icon.offsetWidth, 'x', icon.offsetHeight);
    }
    
    // 页面加载时调整
    window.addEventListener('load', adjustIconSize);
    
    // 窗口大小变化时调整
    window.addEventListener('resize', adjustIconSize);
    
    // 立即执行一次
    setTimeout(adjustIconSize, 0);
    
    // Tauri API 调用
    let invoke;
    
    function getInvoke() {
      if (window.__TAURI_INTERNALS__?.invoke) {
        const fn = window.__TAURI_INTERNALS__.invoke;
        return typeof fn === 'function' ? fn.bind(window.__TAURI_INTERNALS__) : null;
      }
      if (window.__TAURI_INTERNALS__?.core?.invoke) {
        const fn = window.__TAURI_INTERNALS__.core.invoke;
        return typeof fn === 'function' ? fn.bind(window.__TAURI_INTERNALS__.core) : null;
      }
      if (window.__TAURI__?.invoke) {
        const fn = window.__TAURI__.invoke;
        return typeof fn === 'function' ? fn.bind(window.__TAURI__) : null;
      }
      return null;
    }
    
    invoke = getInvoke();
    
    if (!invoke) {
      let retries = 0;
      const interval = setInterval(() => {
        invoke = getInvoke();
        if (invoke || ++retries >= 20) {
          clearInterval(interval);
        }
      }, 100);
    }
    
    let isDragging = false;
    let startMousePos = { x: 0, y: 0 };
    let lastClickTime = 0;
    let clickTimeout = null;
    const DOUBLE_CLICK_DELAY = 300; // 双击间隔时间（毫秒）
    const DRAG_THRESHOLD = 5; // 拖拽阈值（像素）
    
    document.addEventListener('contextmenu', e => e.preventDefault());
    
    document.addEventListener('mousedown', async (e) => {
      if (e.button === 0) {
        isDragging = true;
        startMousePos = { x: e.screenX, y: e.screenY };
        
        if (!invoke) invoke = getInvoke();
        if (invoke) {
          try {
            await invoke('icon_mouse_down', { x: e.screenX, y: e.screenY });
          } catch (err) {
            console.error('Mouse down error:', err);
          }
        }
        
        e.preventDefault();
      }
    });
    
    document.addEventListener('mousemove', async (e) => {
      if (isDragging) {
        if (!invoke) invoke = getInvoke();
        if (invoke) {
          try {
            await invoke('icon_mouse_move', { x: e.screenX, y: e.screenY });
          } catch (err) {
            console.error('Move error:', err);
          }
        }
        e.preventDefault();
      }
    });
    
    // 处理双击（全局唯一：双击呼出/隐藏主界面）
    // 完全禁用单击，只响应双击
    document.addEventListener('mouseup', async (e) => {
      if (e.button === 0 && isDragging) {
        const moved = Math.abs(e.screenX - startMousePos.x) > DRAG_THRESHOLD || 
                      Math.abs(e.screenY - startMousePos.y) > DRAG_THRESHOLD;
        isDragging = false;
        
        if (!invoke) invoke = getInvoke();
        if (invoke) {
          try {
            await invoke('icon_mouse_up', { x: e.screenX, y: e.screenY });
            
            // 只有在没有拖拽的情况下才处理双击检测
            if (!moved) {
              const currentTime = Date.now();
              const timeSinceLastClick = currentTime - lastClickTime;
              
              // 清除之前的单击超时（完全禁用单击）
              if (clickTimeout) {
                clearTimeout(clickTimeout);
                clickTimeout = null;
              }
              
              // 检查是否是双击（两次点击间隔小于 DOUBLE_CLICK_DELAY）
              if (timeSinceLastClick < DOUBLE_CLICK_DELAY && timeSinceLastClick > 0) {
                // 双击：立即触发呼出/隐藏主界面
                lastClickTime = 0; // 重置，避免触发第三次点击
                if (!invoke) invoke = getInvoke();
                if (invoke) {
                  try {
                    await invoke('icon_click');
                  } catch (err) {
                    console.error('Double click error:', err);
                  }
                }
              } else {
                // 第一次点击，记录时间，等待可能的第二次点击
                // 不设置任何超时，完全禁用单击
                lastClickTime = currentTime;
              }
            }
          } catch (err) {
            console.error('Mouse up error:', err);
          }
        }
        
        e.preventDefault();
      }
    });
    
    // 使用原生 dblclick 事件作为主要触发方式（更可靠）
    document.addEventListener('dblclick', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // 清除单击超时和状态
      if (clickTimeout) {
        clearTimeout(clickTimeout);
        clickTimeout = null;
      }
      lastClickTime = 0;
      
      // 确保没有在拖拽
      if (!isDragging) {
        if (!invoke) invoke = getInvoke();
        if (invoke) {
          try {
            await invoke('icon_click');
          } catch (err) {
            console.error('Double click error:', err);
          }
        }
      }
    });
    
    document.addEventListener('selectstart', e => e.preventDefault());
    window.addEventListener('mouseup', () => { 
      isDragging = false; 
    });
    document.addEventListener('mouseleave', () => { 
      isDragging = false; 
    });
  </script>
</body>
</html>
